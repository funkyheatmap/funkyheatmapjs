{"mappings":"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","sources":["d3.js","src/main.js","_.js","src/input_util.js","src/columns.js","src/palettes.js","src/legends.js","src/geoms.js"],"sourcesContent":["module.exports=d3;","import * as d3 from 'd3';\nimport * as _ from 'lodash';\n\nimport { ensureRowData, rowToColData } from './input_util';\nimport { createColumns, buildColumnGroups, Column } from './columns';\nimport { assignPalettes } from './palettes';\nimport { prepareLegends } from './legends';\nimport { GEOMS } from './geoms';\n\n\n/**\n * @typedef {Object} ColumnData\n * @description A dataframe in column-based format. Each property is a column, represented as an\n *   array. All columns are of the same length.\n * @example\n * {\n *   'model': ['Toyota Corolla', 'Fiat 128', 'Honda Civic'],\n *   'mpg': [33.9, 32.4, 30.4],\n *   'weight': [1.835, 2.2, 1.615]\n * }\n */\n\n/**\n * @typedef {Object[]} RowData\n * @description A dataframe in row-based format. Each element is an object with properties. All\n *   objects have the same properties.\n * @example\n * [\n *   {model: 'Toyota Corolla', mpg: 33.9, weight: 1.835},\n *   {model: 'Fiat 128', mpg: 32.4, weight: 2.2},\n *   {model: 'Honda Civic', mpg: 30.4, weight: 1.615}\n * ]\n */\n\n/**\n * @typedef {Object} RowInfo\n * @description Minimal metadata for each row in the heatmap. Used to group rows.\n * @property {string} group - group id for the row\n */\n\n/**\n * @typedef {Object} RowGroup\n * @description ID and title for a row group for display. Rows within a group are visually apart\n *   and are sorted together.\n * @property {string} group - group id, must match the `group` property in {@link RowInfo}\n * @property {string} Group - group title for display. _Required_ to enable row grouping\n */\n\n/**\n * @typedef {Object} HeatmapOptions\n * @property {boolean} [colorByRank=false] - whether to color elements by rank, default for all\n *   numeric columns\n * @property {number} [legendFontSize=12] - font size for legend labels\n * @property {boolean} [labelGroupsAbc=false] - whether to add alphabetical index to column groups\n *   labels\n * @property {number} [tooltipPrecision=4] - number of decimal places for floats in the tooltip\n * @property {Object} [theme] - theme options\n * @property {string} [theme.oddRowBackground='white'] - background color for odd rows\n * @property {string} [theme.evenRowBackground='#eee'] - background color for even rows\n * @property {string} [theme.textColor='black'] - color for text\n * @property {string} [theme.strokeColor='#555'] - edge color for geoms and guides\n * @property {string} [theme.headerColorL1='white'] - color for column groups of the first level\n * @property {string} [theme.headerColorRest='black'] - color for column groups if the other levels\n * @property {string} [theme.hoverColor='#1385cb'] - color for hovered text\n */\nconst DEFAULT_OPTIONS = {\n    legendFontSize: 12,\n    legendTicks: [0, 0.2, 0.4, 0.6, 0.8, 1],\n    labelGroupsAbc: false,\n    colorByRank: false,\n    tooltipPrecision: 4,\n    theme: {\n        oddRowBackground: 'white',\n        evenRowBackground: '#eee',\n        textColor: 'black',\n        strokeColor: '#555',\n        headerColorL1: 'white',\n        headerColorRest: 'black',\n        hoverColor: '#1385cb'\n    }\n};\n\n/**\n * @typedef {Object} PositionOptions\n * @property {number} [rowHeight=24] - height of a heatmap row, in pixels\n * @property {number} [rowSpace=0.1] - space between rows, as a fraction of rowHeight. Twice the\n *   padding\n * @property {number} [rowBigspace=1] - space between groups of rows, as a fraction of rowHeight\n * @property {number} [colWidth=24] - width of a heatmap column, in pixels. Deprecated, has no\n *   effect\n * @property {number} [colSpace=0.1] - space between columns, as a fraction of rowHeight. Twice the\n *   padding\n * @property {number} [colBigspace=1] - space between groups of columns, as a fraction of rowHeight\n * @property {number} [colAnnotOffset=10] - offset of column groups from column labels, in pixels\n * @property {number} [colAnnotAngle=30] - angle of column labels, in degrees\n * @property {number} [padding=5] - padding for various uses\n * @property {number} [minGeomSize=0.25] - minimum size of a heatmap element, in pixels\n * @property {number} [funkyMidpoint=0.8] - midpoint for funkyrect geom, see\n *   {@link module:geoms.funkyrect|funkyrect}\n */\nconst DEFAULT_POSITION_ARGS = {\n    rowHeight: 24,\n    rowSpace: 0.1,\n    rowBigspace: 1,\n    colWidth: 24,\n    colSpace: 0.1,\n    colBigspace: 1,\n    colAnnotOffset: 10,\n    colAnnotAngle: 30,\n    padding: 5,\n    minGeomSize: 0.25,\n    funkyMidpoint: 0.8\n}\n\n/**\n * Positional options for the heatmap.\n * @extends PositionOptions\n * @property {number} rowSpacePx - space between rows, in pixels. _Calculated_\n * @property {number} rowBigspacePx - space between groups of rows, in pixels. _Calculated_\n * @property {number} colSpacePx - space between columns, in pixels. _Calculated_\n * @property {number} geomSize - size of a heatmap element, in pixels. _Calculated_\n * @property {number} geomPadding - padding around heatmap elements, in pixels. _Calculated_\n * @property {number} geomPaddingX - padding around heatmap elements in the x direction, in pixels.\n *   _Calculated_\n * @property {number} bodyHeight - height of the heatmap body, in pixels. _Calculated_\n * @property {number} bodyWidth - width of the heatmap body, in pixels. _Calculated_\n * @property {number} width - width of the heatmap, in pixels, including header and footer.\n *   _Calculated_\n * @property {number} headerHeight - height of the header, in pixels. _Calculated_\n * @property {number} footerHeight - height of the footer, in pixels. _Calculated_\n * @property {number} footerOffset - offset of the footer from the left edge of the heatmap,\n *   in pixels. _Calculated_\n */\nclass PositionArgs {\n    /**\n     * Initialize the PositionArgs object from the provided options. Handles deprecation warnings\n     * and calls {@link PositionArgs#calculate|calculate} to pre-calculate values.\n     *\n     * @param {PositionOptions} args - object with positional options\n     */\n    constructor(args) {\n        _.extend(this, DEFAULT_POSITION_ARGS);\n        _.extend(this, args);\n        let underscoreDeprecatedArgs = [];\n        let deprecatedArgs = [];\n        for (let key of Object.getOwnPropertyNames(args)) {\n            let underscore = key.indexOf('_');\n            if (underscore > -1) {\n                let newKey;\n                while (underscore > -1) {\n                    newKey = key.slice(0, underscore) + key[underscore + 1].toUpperCase() + key.slice(underscore + 2);\n                    underscore = key.indexOf('_', underscore + 1);\n                }\n                this[newKey] = args[key];\n                underscoreDeprecatedArgs.push(key);\n                key = newKey;\n            }\n            if (key.startsWith('expand') || key == 'colWidth') {\n                deprecatedArgs.push(key);\n            }\n        }\n        if (underscoreDeprecatedArgs.length > 0) {\n            let msg = 'Position arguments with underscores were accepted, but are deprecated. Use camelCase instead.';\n            msg += ` Found: ${underscoreDeprecatedArgs.join(', ')}`;\n            console.warn(msg);\n        }\n        if (deprecatedArgs.length > 0) {\n            let msg = 'The following position arguments are deprecated and have no effect: ';\n            msg += deprecatedArgs.join(', ');\n            console.warn(msg);\n        }\n        this.calculate();\n    }\n\n    /**\n     * Pre-calculate needed values based on the options.\n     */\n    calculate() {\n        this.rowSpacePx = this.rowHeight * this.rowSpace;\n        this.rowBigspacePx = this.rowHeight * this.rowBigspace;\n        this.colSpacePx = this.rowHeight * this.colSpace;\n        // assuming square\n        this.geomSize = this.rowHeight - this.rowSpacePx;\n        this.geomPadding = this.rowSpacePx / 2;\n        this.geomPaddingX = this.colSpacePx / 2;\n    }\n}\n\n/**\n * Heatmap class responsible for rendering the heatmap and handling user interactions. Takes\n * preprocessed user data and stores it, along with the configuration options\n *\n * @property {PositionArgs} positionArgs\n * @property {HeatmapOptions} options\n * @property {SVGElement} svg - SVG element to render the heatmap in\n * @property {RowData} data - data to be visualized\n * @property {module:columns.Column[]} columnInfo - information about columns\n * @property {Map<string, module:columns~ColumnGroup>} columnGroups - column groups\n * @property {RowInfo[]} rowInfo - information about rows\n * @property {Map<string, module:columns~ColumnGroup>} rowGroups - row groups\n * @property {module:palettes~PaletteMapping} palettes - palettes used in the heatmap\n * @property {module:legends~LegendInfo[]} legends - legends to be displayed\n */\nclass FunkyHeatmap {\n    /**\n     * Calls {@link FunkyHeatmap#calculateOptions|calculateOptions} to pre-calculate some derived\n     * values.\n     *\n     * @param {RowData} data - data to be visualized\n     * @param {module:columns.Column[]} columnInfo - information about columns\n     * @param {module:columns~ColumnGroup[]} columnGroups - column groups\n     * @param {RowInfo[]} rowInfo - information about rows\n     * @param {RowGroup[]} rowGroups - row groups\n     * @param {module:palettes~PaletteMapping} palettes - palettes used in the heatmap\n     * @param {module:legends~LegendInfo[]} legends - legends to be displayed\n     * @param {PositionOptions} positionArgs - position arguments\n     * @param {HeatmapOptions} options - heatmap options\n     * @param {SVGElement} svg - SVG element to render the heatmap in\n     */\n    constructor(\n        data,\n        columnInfo,\n        columnGroups,\n        rowInfo,\n        rowGroups,\n        palettes,\n        legends,\n        positionArgs,\n        options,\n        svg\n    ) {\n        this.rowGroupKey = '__group';\n\n        this.data = data;\n        this.columnInfo = columnInfo;\n        this.columnGroups = d3.index(columnGroups, group => group.group);\n        this.rowInfo = rowInfo;\n        this.rowGroups = d3.index(rowGroups, group => group.group);\n        this.palettes = palettes;\n        this.legends = legends;\n        this.positionArgs = new PositionArgs(positionArgs);\n        this.options = _.merge(DEFAULT_OPTIONS, options);\n        this.calculateOptions();\n        this.svg = svg;\n    }\n\n    /**\n     * Determines if we render row groups and in which order.\n     * @protected\n     */\n    calculateOptions() {\n        this.renderGroups = false;\n\n        this.rowGroupOrder = [];\n        // if we don't have row groups, put all rows in an unnamed group\n        if (this.rowInfo.length === 0 || this.rowInfo[0].group === undefined) {\n            this.rowInfo = this.data.map(_ => { return {group: ''} });\n        }\n\n        this.data.forEach((d, i) => {\n            const group = this.rowInfo[i].group;\n            d[this.rowGroupKey] = group;\n            if (this.rowGroupOrder.indexOf(group) === -1) {\n                this.rowGroupOrder.push(group);\n            }\n        });\n        const group = this.rowInfo[0].group\n        const groupInfo = this.rowGroups.get(group);\n        if (groupInfo !== undefined && groupInfo.Group !== undefined) {\n            this.renderGroups = true;\n        }\n    }\n\n    /**\n     * Renders the heatmap's striped background.\n     * @protected\n     */\n    renderStripedRows() {\n        const O = this.options;\n        const P = this.positionArgs;\n\n        let rowGroup, nGroups = 0, colorCounter = 0;\n        this.data.forEach((d, i) => {\n            if (this.renderGroups && d[this.rowGroupKey] !== rowGroup) {\n                nGroups += 1;\n                colorCounter = 0;\n            }\n            rowGroup = d[this.rowGroupKey];\n            this.body.append('rect')\n                .classed('row', true)\n                .attr('height', P.rowHeight)\n                .attr('x', 0)\n                .attr('y', (i + nGroups) * P.rowHeight)\n                .attr('fill', colorCounter % 2 === 0\n                                ? O.theme.evenRowBackground\n                                : O.theme.oddRowBackground);\n            colorCounter += 1;\n        });\n    }\n\n    /**\n     * Renders data column by column.\n     * @protected\n     */\n    renderData() {\n        const O = this.options;\n        const P = this.positionArgs;\n\n        let offset = 0;\n        P.bodyHeight = this.data.length * P.rowHeight;\n        if (this.renderGroups) {\n            P.bodyHeight += this.rowGroups.size * P.rowHeight;\n        }\n        let prevColGroup;\n\n        this.columnInfo.forEach((column, i) => {\n            let maxWidth = 0;\n            let padding = P.geomPaddingX;\n            let firstColumn = i === 0;\n            if (column.geom === 'text' || column.geom === 'bar') {\n                padding = P.padding;\n            }\n            offset += padding;\n            if (prevColGroup && column.group && prevColGroup !== column.group) {\n                offset += 2 * P.padding;\n            }\n            let rowGroup, nGroups = 0;\n            this.data.forEach((item, j) => {\n                let width = 0;\n                if (this.renderGroups && item[this.rowGroupKey] !== rowGroup) {\n                    nGroups += 1;\n                }\n                if (this.renderGroups && firstColumn && item[this.rowGroupKey] !== rowGroup) {\n                    let groupName = GEOMS.text(\n                        this.rowGroups.get(item[this.rowGroupKey]).Group,\n                        null,\n                        column,\n                        O,\n                        P\n                    );\n                    groupName\n                        .classed('fh-row-group-name', true)\n                        .attr('transform', `translate(${offset - padding}, ${(j + nGroups - 1) * P.rowHeight - 2 * P.geomPadding})`)\n                        .attr('font-weight', 'bold')\n                        .attr('dominant-baseline', 'hanging');\n                    this.body.append(() => groupName.node());\n                    width = groupName.node().getBBox().width;\n                    if (nGroups > 1) {\n                        const rowGroupWhiteBack = d3.create('svg:rect')\n                            .classed('fh-row-group-back', true)\n                            .attr('x', 0)\n                            .attr('y', 0)\n                            .attr('height', P.rowHeight)\n                            .attr('fill', O.theme.oddRowBackground)\n                            .attr('transform', `translate(${offset - padding}, ${(j + nGroups - 1) * P.rowHeight})`);\n                        this.body.append(() => rowGroupWhiteBack.node());\n                    }\n                }\n                rowGroup = item[this.rowGroupKey];\n                let value = column.getValue(item);\n                if (value === undefined || value === null || (isNaN(value) && column.numeric)) {\n                    return;\n                }\n                let colorValue = column.getColorValue(item, j);\n                let label;\n                if (column.label) {\n                    label = item[column.label];\n                }\n                if (GEOMS[column.geom] === undefined) {\n                    throw `Geom ${column.geom} not implemented. Use one of ${Object.keys(GEOMS).join(', ')}.`;\n                }\n                let el = GEOMS[column.geom](value, colorValue, column, O, P);\n                if (label) {\n                    const labelColor = d3.hsl(column.palette(colorValue)).l > 0.5\n                        ? 'black'\n                        : 'white';\n                    const g = d3.create('svg:g')\n                        .classed('fh-geom', true);\n                    g.append(() => el.classed('fh-geom', false).classed('fh-orig-geom', true).node());\n                    // By default place label in the center of the geom\n                    let labelX = P.rowHeight / 2;\n                    if (column.geom === 'bar') {\n                        // Bars are of different widths, place label on the left\n                        labelX = P.padding + P.geomPaddingX * 3;\n                    }\n                    g.append('text')\n                        .attr('x', labelX)\n                        .attr('y', P.rowHeight / 2)\n                        .attr('text-anchor', 'middle')\n                        .attr('dominant-baseline', 'central')\n                        .attr('fill', labelColor)\n                        .text(label);\n                    el = g;\n                }\n                el.attr('transform', `translate(${offset}, ${(j + nGroups) * P.rowHeight})`);\n                const tooltipValue = column.getHoverText(item, O.tooltipPrecision);\n                if (tooltipValue !== undefined) {\n                    el.datum({tooltip: tooltipValue});\n                }\n                if (column.geom === 'pie') {\n                    const s = 'margin: 5px; border-collapse: collapse; border-top: 1px solid #aaa; border-left: 1px solid #aaa; font-size: 80%';\n                    const s2 = 'padding: 2px 4px; border-bottom: 1px solid #aaa; border-right: 1px solid #aaa';\n                    let tooltip = `<table style=\"${s}\">${column.palette.colorNames.map((colorName, i) => {\n                        return `<tr><td style=\"${s2}\">${colorName}:</td><td style=\"${s2}\">${value[i].toFixed(O.tooltipPrecision)}</td></tr>`;\n                    }).join('')}</table>`;\n                    el.datum({tooltip: tooltip});\n                }\n                this.body.append(() => el.node());\n                let elWidth;\n                if (label) {\n                    elWidth = el.select('.fh-orig-geom').node().getBBox().width;\n                } else {\n                    elWidth = el.node().getBBox().width;\n                }\n                if (column.geom === 'image') {\n                    elWidth = column.width;\n                }\n                if (elWidth > width) {\n                    width = elWidth;\n                }\n                if (width > maxWidth) {\n                    maxWidth = width;\n                }\n                if (label) {\n                    label = el.select('text');\n                    let fontSize = 100;\n                    for (let q = 0; q < 12; q++) {\n                        const { width } = label.node().getBBox();\n                        if (width > P.geomSize - P.geomPaddingX * 2) {\n                            fontSize -= 5;\n                            label.attr('font-size', `${fontSize}%`);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            });\n            if (column.geom === 'bar' && column.options.drawGuide !== false) {\n                maxWidth = P.geomSize * column.width + P.geomPadding;\n                this.body.append('line')\n                    .attr('x1', offset + maxWidth)\n                    .attr('x2', offset + maxWidth)\n                    .attr('y1', this.renderGroups ? P.rowHeight : 0)\n                    .attr('y2', P.bodyHeight)\n                    .attr('stroke', O.theme.strokeColor)\n                    .attr('stroke-dasharray', '5 5')\n                    .attr('opacity', 0.5);\n            }\n            column.widthPx = Math.max(maxWidth, P.rowHeight);\n            column.widthPx = Math.round(column.widthPx);\n            column.offset = offset;\n            offset += column.widthPx + padding;\n            prevColGroup = column.group;\n        });\n        P.bodyWidth = offset + P.colSpacePx;\n        this.body.selectAll('.fh-row-group-back').attr('width', P.bodyWidth).raise();\n        this.body.selectAll('.fh-row-group-name').raise();\n    }\n\n    /**\n     * Renders column labels and groups.\n     * @protected\n     */\n    renderHeader() {\n        const O = this.options;\n        const P = this.positionArgs;\n\n        let headerHeight = 0;\n        let bodyWidth = 0;\n        let nonZeroRotate = false;\n        const groups = this.header.append('g');\n        const columnGroups = Array.from(this.columnGroups.values());\n\n        const nLevels = Math.max(...columnGroups.map(group => {\n            let i = 1;\n            while (true) {\n                if (group[`level${i}`] === undefined) {\n                    break;\n                }\n                i += 1;\n            }\n            return i - 1;\n        }));\n        const groupsHeight = this.columnGroups.size === 0 ? 0 : nLevels * (P.rowHeight + P.padding);\n\n        const labels = this.header.append('g')\n            .attr('transform', `translate(0, ${groupsHeight + P.colAnnotOffset})`);\n\n        let abcCounter = 0;\n        for (let level = 0; level < nLevels; level++) {\n            const levelID = `level${level + 1}`;\n            let levelName;\n            let groupStart;\n            // iterate over columns _in order_\n            this.columnInfo.forEach((column, columnIdx) => {\n                const groupInfo = this.columnGroups.get(column.group);\n\n                let nextCol, nextColGroup;\n                // peek at the next column group. If we're at the last column, or if the next group\n                // is empty, it's the same: we draw current group\n                if (this.columnInfo.length > columnIdx + 1) {\n                    nextCol = this.columnInfo[columnIdx + 1];\n                    nextColGroup = this.columnGroups.get(nextCol.group);\n                }\n\n                if (groupInfo && groupInfo[levelID] !== undefined && levelName === undefined) {\n                    // start a new group if we haven't started yet\n                    levelName = groupInfo[levelID];\n                    groupStart = column.offset;\n                }\n                if (levelName !== undefined\n                    && (nextColGroup === undefined\n                        || levelName !== nextColGroup[levelID])\n                ) {\n                    // if we have a group and the next column is not in the same group, draw the\n                    // current group until the current column\n                    const groupEnd = column.offset + column.widthPx + P.geomPadding;\n                    const groupCol = new Column({\n                        id: '_group',\n                        palette: groupInfo.palette\n                    }, [1]);\n                    assignPalettes([groupCol], this.palettes);\n                    const fill = (\n                        groupCol.palette == 'none' && 'transparent' || groupCol.palette(0.5)\n                    );\n                    const yOffset = level * P.rowHeight + level * P.padding;\n                    const rect = groups.append('rect')\n                        .attr('x', groupStart)\n                        .attr('y', yOffset)\n                        .attr('width', groupEnd - groupStart)\n                        .attr('height', P.rowHeight)\n                        .attr('fill', fill)\n                        .attr('opacity', level === 0 && 1 || 0.25);\n                    const text = groups.append('text')\n                        .attr('x', groupStart + (groupEnd - groupStart) / 2)\n                        .attr('y', yOffset + P.rowHeight / 2)\n                        .attr('text-anchor', 'middle')\n                        .attr('dominant-baseline', 'central')\n                        .attr(\n                            'fill',\n                            level === 0 && O.theme.headerColorL1 || O.theme.headerColorRest\n                        )\n                        .text(levelName);\n                    if (O.fontSize) {\n                        text.attr('font-size', O.fontSize);\n                    }\n                    const { width } = text.node().getBBox();\n                    if (width + 2 * P.padding > groupEnd - groupStart) {\n                        const diff = width + 2 * P.padding - (groupEnd - groupStart);\n                        rect.attr('width', width + 2 * P.padding);\n                        rect.attr('x', groupStart - diff / 2);\n                    }\n                    if (O.labelGroupsAbc && level === 0) {\n                        // only add ABC labels for the first level\n                        const letter = String.fromCharCode(\"a\".charCodeAt(0) + abcCounter);\n                        const text = groups.append('text')\n                            .attr('x', groupStart + P.padding)\n                            .attr('y', yOffset + P.rowHeight / 2)\n                            .attr('dominant-baseline', 'central')\n                            .attr('fill', O.theme.headerColorL1)\n                            .text(`${letter})`);\n                        if (O.fontSize) {\n                            text.attr('font-size', O.fontSize);\n                        }\n                    }\n                    abcCounter += 1;\n                    // we have drawn the group, reset the variables\n                    levelName = undefined;\n                }\n            });\n        }\n\n        this.columnInfo.forEach((column, i) => {\n            const el = labels.append('g')\n                .attr('transform', `rotate(${-P.colAnnotAngle})`)\n                .classed(`column-${i}`, true);\n            el.append('svg:text')\n                .attr('x', 0)\n                .attr('y', 0)\n                .attr('font-size', O.fontSize)\n                .style('fill', O.theme.textColor)\n                .style('cursor', 'pointer')\n                .datum(column)\n                .on('click', this.onColumnClick.bind(this))\n                .on('mouseenter', () => {\n                    el.select('text')\n                        .style('text-decoration', 'underline')\n                        .style('text-decoration-style', 'dashed')\n                        .style('text-decoration-color', O.theme.hoverColor)\n                        .style('fill', O.theme.hoverColor);\n                })\n                .on('mouseleave', () => {\n                    el.select('text')\n                        .style('text-decoration', '')\n                        .style('text-decoration-style', '')\n                        .style('text-decoration-color', '')\n                        .style('fill', '');\n                })\n                .text(column.name);\n            const nativeWidth = el.node().getBBox().width;\n            if (!nonZeroRotate && nativeWidth < column.widthPx - 2 * P.padding) {\n                column.rotate = false;\n            } else {\n                column.rotate = true;\n                nonZeroRotate = true;\n            }\n            const { width, height } = el.node().getBoundingClientRect();\n            if (height > headerHeight) {\n                headerHeight = height;\n            }\n            if (column.offset + column.widthPx / 2 + width > bodyWidth) {\n                bodyWidth = column.offset + column.widthPx / 2 + width + P.padding;\n            }\n        });\n        this.columnInfo.forEach((column, i) => {\n            let center = column.offset + column.widthPx / 2;\n            let rotate = column.rotate ? -P.colAnnotAngle : 0;\n            this.header.select(`.column-${i}`)\n                .attr(\n                    'transform',\n                    `translate(${center}, ${headerHeight - 2 * P.padding}) rotate(${rotate})`\n                );\n            if (!column.rotate) {\n                labels.select(`.column-${i} text`)\n                    .attr('text-anchor', 'middle');\n            } else {\n                labels.append('line')\n                    .attr('x1', center)\n                    .attr('x2', center)\n                    .attr('y1', headerHeight - 2)\n                    .attr('y2', headerHeight - 2 - P.padding)\n                    .attr('stroke', O.theme.strokeColor);\n            }\n        });\n        P.width = bodyWidth;\n        P.headerHeight = headerHeight + groupsHeight + P.colAnnotOffset;\n    }\n\n    /**\n     * Renders the footer with legends.\n     * @protected\n     */\n    renderLegends() {\n        const O = this.options;\n        const P = this.positionArgs;\n\n        // go through this.legends and render them sequentially\n\n        let footerHeight = 0;\n        const legendEl = this.footer.append('g');\n        let legendXOffset = 0;\n        let offset = 0;\n        let funkyrectPresent = false;\n\n        this.legends.forEach(legend => {\n            if (!legend.enabled) {\n                return;\n            }\n            const rowHeight = O.legendFontSize;\n            let offsetY = rowHeight * 2 + P.padding;\n            const el = legendEl.append('g');\n            el.attr('transform', `translate(${offset}, 0)`);\n            el.append('text')\n                .attr('x', 0)\n                .attr('y', offsetY)\n                .attr('font-size', O.legendFontSize)\n                .style('fill', O.theme.textColor)\n                .text(legend.title);\n\n            if (legend.geom === 'text') {\n                let labelsWidth = 0;\n                legend.labels.forEach((label, i) => {\n                    const txt = el.append('text')\n                        .attr('x', P.padding)\n                        .attr('y', offsetY + (i + 1) * (rowHeight + P.padding))\n                        .attr('font-size', O.legendFontSize)\n                        .style('fill', O.theme.textColor)\n                        .text(label);\n                    const { width } = txt.node().getBBox();\n                    if (width > labelsWidth) {\n                        labelsWidth = width;\n                    }\n                });\n                legend.values.forEach((value, i) => {\n                    el.append('text')\n                        .attr('x', P.padding * 2 + labelsWidth)\n                        .attr('y', offsetY + (i + 1) * (rowHeight + P.padding))\n                        .attr('font-size', O.legendFontSize)\n                        .style('fill', O.theme.textColor)\n                        .text(value);\n                });\n            }\n            if (legend.geom === 'rect') {\n                let myOffset = 0;\n                legend.values.forEach((colorValue, i) => {\n                    const label = legend.labels[i];\n                    const size = legend.size[i];\n                    const geom = GEOMS.rect(size, colorValue, legend, O, P);\n                    geom.attr('transform', `translate(${myOffset}, ${offsetY + P.padding})`);\n                    el.append(() => geom.node());\n                    let x = myOffset;\n                    let textAnchor = 'start';\n                    if (legend.label_align === 'center') {\n                        x += P.rowHeight / 2;\n                        textAnchor = 'middle';\n                    } else if (legend.label_align === 'right') {\n                        x += P.rowHeight;\n                        textAnchor = 'end';\n                    }\n                    el.append('text')\n                        .attr('x', x)\n                        .attr('y', offsetY + P.rowHeight + rowHeight + P.padding)\n                        .attr('font-size', O.legendFontSize)\n                        .attr('text-anchor', textAnchor)\n                        .style('fill', O.theme.textColor)\n                        .text(label);\n                    myOffset += P.geomSize + P.padding;\n                });\n            }\n            if (legend.geom === 'funkyrect') {\n                let myOffset = 0;\n                legend.labels.forEach((label, i) => {\n                    const colorValue = legend.values[i];\n                    const size = legend.size[i];\n                    const geom = GEOMS.funkyrect(size, colorValue, legend, O, P);\n                    el.append(() => geom.node());\n                    const { width: geomWidth, height: geomHeight } = geom.node().getBBox();\n                    geom.attr(\n                        'transform',\n                        `translate(${myOffset}, ${offsetY + P.rowHeight / 2 - geomHeight / 2})`\n                    );\n                    let x = myOffset + P.rowHeight / 2 - geomWidth / 2;\n                    let textAnchor = 'start';\n                    if (legend.label_align === 'center') {\n                        x += geomWidth / 2;\n                        textAnchor = 'middle';\n                    } else if (legend.label_align === 'right') {\n                        x += geomWidth;\n                        textAnchor = 'end';\n                    }\n                    el.append('text')\n                        .attr('x', x)\n                        .attr('y', offsetY + P.rowHeight + rowHeight + P.padding)\n                        .attr('font-size', O.legendFontSize)\n                        .attr('text-anchor', textAnchor)\n                        .style('fill', O.theme.textColor)\n                        .text(label);\n                    myOffset += geomWidth + P.padding;\n                });\n            }\n            if (legend.geom === 'circle') {\n                let myOffset = 0;\n                legend.labels.forEach((label, i) => {\n                    const colorValue = legend.values[i];\n                    const size = legend.size[i];\n                    const geom = GEOMS.circle(size, colorValue, legend, O, P);\n                    el.append(() => geom.node());\n                    const { width: geomWidth, height: geomHeight } = geom.node().getBBox();\n                    geom.attr(\n                        'transform',\n                        `translate(${myOffset}, ${offsetY + P.rowHeight / 2 - geomHeight / 2})`\n                    );\n                    let x = myOffset + P.rowHeight / 2 - geomWidth / 2;\n                    let textAnchor = 'start';\n                    if (legend.label_align === 'center') {\n                        x += geomWidth / 2;\n                        textAnchor = 'middle';\n                    } else if (legend.label_align === 'right') {\n                        x += geomWidth;\n                        textAnchor = 'end';\n                    }\n                    el.append('text')\n                        .attr('x', x)\n                        .attr('y', offsetY + P.rowHeight + rowHeight + P.padding)\n                        .attr('font-size', O.legendFontSize)\n                        .attr('text-anchor', textAnchor)\n                        .style('fill', O.theme.textColor)\n                        .text(label);\n                    myOffset += geomWidth + P.padding;\n                });\n            }\n            if (legend.geom === 'bar') {\n                const colors = legend.palette.range();\n\n                const grad = this.svg.append('defs')\n                    .append('linearGradient')\n                    .attr('id', `grad_${legend.paletteName}`)\n                    .attr('x1', '0%')\n                    .attr('x2', '100%')\n                    .attr('y1', '0%')\n                    .attr('y2', '0%');\n\n                grad.selectAll('stop')\n                    .data(colors)\n                    .enter()\n                    .append('stop')\n                    .style('stop-color', function(d) { return d; })\n                    .attr('offset', function(d, i) {\n                        return 100 * (i / (colors.length - 1)) + '%';\n                    });\n\n                // A bit ugly to get the width of the column mapped to this legend\n                const col = this.columnInfo.filter((column) =>\n                    column.geom === 'bar' && column.paletteName === legend.paletteName\n                )[0];\n\n                el.append('rect')\n                    .attr('x', P.padding)\n                    .attr('y', offsetY + P.padding)\n                    .attr('width', col.widthPx)\n                    .attr('height', P.rowHeight)\n                    .style('fill', `url(#grad_${legend.paletteName})`)\n                    .attr('stroke', 'black')\n                    .attr('stroke-width', 0.5);\n\n                legend.labels.forEach((label, i) => {\n                    if (label === '') {\n                        return;\n                    }\n                    const value = legend.values[i];\n                    const xPos = P.padding + col.widthPx * value;\n                    if (value > 0 && value < 1) {\n                        el.append('line')\n                            .attr('x1', xPos)\n                            .attr('x2', xPos)\n                            .attr('y1', offsetY + P.rowHeight + P.padding)\n                            .attr('y2', offsetY + P.rowHeight)\n                            .attr('stroke', 'black')\n                            .attr('stroke-width', 0.5);\n                    }\n                    el.append('text')\n                        .attr('x', xPos)\n                        .attr('y', offsetY + P.rowHeight + rowHeight + P.padding)\n                        .attr('font-size', O.legendFontSize)\n                        .attr('text-anchor', 'middle')\n                        .style('fill', O.theme.textColor)\n                        .text(label);\n                });\n            }\n            if (legend.geom === 'image') {\n                legend.values.forEach((value, i) => {\n                    const label = legend.labels[i];\n                    const img = GEOMS.image(value, null, {width: legend.size[i]}, O, P);\n                    img.attr('transform', `translate(0, ${offsetY + P.padding})`);\n                    el.append(() => img.node());\n                    const { width: imgWidth, height: imgHeight } = img.node().getBBox();\n                    el.append('text')\n                        .attr('x', imgWidth + P.padding)\n                        .attr('y', offsetY + P.padding + imgHeight / 2)\n                        .attr('font-size', O.legendFontSize)\n                        .attr('text-anchor', 'left')\n                        .attr('dominant-baseline', 'central')\n                        .style('fill', O.theme.textColor)\n                        .text(label);\n                    offsetY += imgHeight + P.padding;\n                });\n            }\n            if (legend.geom === 'pie') {\n                const arcs = d3.pie().endAngle(Math.PI)(Array(legend.palette.colorNames.length).fill(1));\n                const g = el.append('g');\n                g.attr('transform', `translate(0, ${offsetY + P.padding + P.rowHeight})`);\n                g.selectAll('arcs')\n                    .data(arcs)\n                    .enter()\n                    .append('path')\n                        .attr('d', d3.arc().innerRadius(0).outerRadius(P.geomSize / 2))\n                        .attr('fill', (_, i) => {\n                            return legend.palette(i);\n                        })\n                        .style('stroke', O.theme.strokeColor)\n                        .style('stroke-width', 1)\n                        .attr('transform', `translate(${P.geomSize / 2 + P.geomPadding - 0.5}, 0)`);\n\n                g.selectAll('text')\n                    .data(arcs)\n                    .enter()\n                    .append('text')\n                    .text((_, i) => legend.palette.colorNames[i])\n                    .attr('font-size', O.legendFontSize)\n                    .attr('dominant-baseline', 'central')\n                    .style('fill', O.theme.textColor)\n                    .attr('transform', d => {\n                        const p = d3.arc().innerRadius(P.geomSize / 2).outerRadius(P.geomSize).centroid(d);\n                        p[0] += P.geomSize / 2 + 4 * P.geomPadding;\n                        return `translate(${p})`;\n                    });\n\n                g.selectAll('lines')\n                    .data(arcs)\n                    .enter()\n                    .append('path')\n                        .attr('d', d => {\n                            const p1 = d3.arc().innerRadius(P.geomSize / 2).outerRadius(P.geomSize / 2 + 5).centroid(d);\n                            const p2 = d3.arc().innerRadius(P.geomSize / 2).outerRadius(P.geomSize - 5).centroid(d);\n                            p1[0] += P.geomSize / 2 + P.geomPadding;\n                            p2[0] += P.geomSize / 2 + 3 * P.geomPadding;\n                            return d3.line()([p1, p2]);\n                        })\n                        .style('stroke', O.theme.strokeColor)\n                        .style('stroke-width', 0.5);\n            }\n\n            const { width } = el.node().getBBox();\n            offset += width + P.padding * 2;\n        });\n\n        const { height } = legendEl.node().getBBox();\n        if (height > footerHeight) {\n            footerHeight = height;\n        }\n        let legendWidth = offset - P.padding;\n        if (funkyrectPresent) {\n            legendWidth += P.geomSize;\n        }\n        if (legendXOffset + legendWidth > P.width) {\n            if (legendWidth <= P.width) { // try to right-justify the legend\n                legendXOffset = P.width - legendWidth;\n            } else {\n                legendXOffset = 0;\n                P.width = offset;\n            }\n        }\n        P.footerOffset = legendXOffset;\n        P.footerHeight = footerHeight + P.rowHeight;\n    }\n\n    /**\n     * @protected\n     */\n    hideTooltip() {\n        if (this.tooltip) {\n            this.tooltip.style(\"display\", \"none\");\n        }\n    }\n\n    /**\n     * @protected\n     */\n    showTooltip(mouse, text) {\n        if (this.tooltip === undefined) {\n            this.tooltip = d3.select(\"body\")\n                .append(\"div\")\n                    .style(\"z-index\", 2000)\n                    .style(\"position\", \"absolute\")\n                    .style(\"background-color\", \"#333\")\n                    .style(\"color\", \"white\")\n                    .style(\"border\", \"solid\")\n                    .style(\"border-width\", \"1px\")\n                    .style(\"border-radius\", \"5px\")\n                    .style(\"padding\", \"3px 5px\")\n                    .style(\"display\", \"none\");\n        }\n\n        const offset = 10;\n        this.tooltip\n            .html(text)\n            .style(\"top\", mouse[1] + 2 * offset + \"px\")\n            .style(\"left\", mouse[0] + offset + \"px\")\n            .style(\"display\", \"block\")\n            .style(\"visibility\", \"none\");\n        const { height } = this.tooltip.node().getBoundingClientRect();\n        this.tooltip.style(\"top\", mouse[1] - height + \"px\")\n            .style(\"visibility\", \"visible\");\n    }\n\n    /**\n     * Event handler for mouse move to trigger showing the tooltip.\n     * @protected\n     */\n    onMouseMove(e) {\n        if (e.target) {\n            let el = d3.select(e.target);\n            while (el.classed('fh-geom') === false && el.node() != this.svg.node()) {\n                el = d3.select(el.node().parentNode);\n            }\n            const d = el.datum();\n            if (d && d.tooltip) {\n                const mouse = d3.pointer(e, document.body);\n                this.showTooltip(mouse, d.tooltip);\n                return;\n            }\n        }\n        this.hideTooltip();\n    }\n\n    /**\n     * Event handler for column click to sort the data and rerender the heatmap.\n     * @protected\n     */\n    onColumnClick(e) {\n        const el = d3.select(e.target);\n        const elBox = el.node().getBBox();\n        const column = el.datum();\n        const comparator = column.sort();\n        let data = d3.group(this.data, d => d[this.rowGroupKey]);\n        data = [].concat(...this.rowGroupOrder.map(group => d3.sort(data.get(group), (a, b) => {\n            [a, b] = [a[column.id], b[column.id]];\n            if (column.numeric) {\n                [a, b] = [+a, +b];\n            }\n            return comparator(a, b);\n        })));\n        this.data = data;\n        const colData = rowToColData(data);\n        this.columnInfo.forEach(column => {\n            column.data = colData[column.id];\n            if (column.numeric) {\n                column.maybeCalculateStats();\n            }\n        });\n        this.svg.selectChildren().remove();\n        this.render();\n\n        this.indicateSort(column, elBox);\n    }\n\n    /**\n     * Draws an arrow indicating the sort order near the corresponding column.\n     * @protected\n     */\n    indicateSort(column, labelBox) {\n        const O = this.options;\n        const P = this.positionArgs;\n\n        this.sortIndicator = this.header.append(\"text\")\n            .attr('font-size', 12)\n            .attr('fill', O.theme.hoverColor);\n        if (column.sortState === \"asc\") {\n            this.sortIndicator.text('↑');\n        } else {\n            this.sortIndicator.text('↓');\n        }\n        this.sortIndicator\n            .attr('text-anchor', 'right')\n            .attr('dominant-baseline', 'text-bottom');\n        let x = column.offset + column.widthPx / 2 - 2 * P.padding;\n        let y = P.headerHeight - P.padding;\n        if (!column.rotate) {\n            x -= labelBox.width / 2;\n            y -= labelBox.height / 2;\n            this.sortIndicator.attr('dominant-baseline', 'central');\n        }\n        this.sortIndicator\n            .attr('x', x)\n            .attr('y', y);\n    }\n\n    /**\n     * Renders the heatmap, calling the necessary functions in order.\n     * @public\n     */\n    render() {\n        this.header = this.svg.append('g');\n        this.body = this.svg.append('g');\n        this.footer = this.svg.append('g');\n\n        this.renderStripedRows();\n        this.renderData();\n        this.renderHeader();\n        this.renderLegends();\n\n        const O = this.options;\n        const P = this.positionArgs;\n\n        this.svg.attr('width', P.width);\n        this.svg.attr('height', P.bodyHeight + P.headerHeight + P.footerHeight);\n        if (this.renderGroups) {\n            this.header.attr('transform', `translate(0, ${P.rowHeight})`);\n        }\n        this.body.selectAll('.row').attr('width', P.bodyWidth);\n        this.body.attr('transform', `translate(0, ${P.headerHeight})`);\n        this.footer.attr('transform', `translate(${P.footerOffset}, ${P.headerHeight + P.bodyHeight})`);\n        this.svg.attr('style', '');\n        if (O.rootStyle) {\n            this.svg.attr('style', O.rootStyle);\n        }\n    }\n\n    /**\n     * Adds event listeners to the SVG element to show and hide the tooltip.\n     * @public\n     */\n    listen() {\n        this.svg.on('mousemove', this.onMouseMove.bind(this));\n        this.svg.on('mouseleave', this.hideTooltip.bind(this));\n    }\n};\n\n\n/**\n * The main entry point for the library. Takes data and various configuration options and returns\n * an SVG element with the heatmap. Internally uses {@link FunkyHeatmap}. Creates a new SVG element\n * and adds it to the DOM immediately, and renders the heatmap offscreen, to be able to calculate\n * the dimensions of text and other elements.\n *\n * @param {ColumnData|RowData} data - data to plot, usually d3-fetch output\n * @param {ColumnData|module:columns~ColumnInfo[]} columnInfo - information about how the columns\n *   should be displayed. If not specified, all columns from `data` will be displayed.\n *   See {@link module:columns~ColumnInfo|ColumnInfo}, {@link module:columns.Column|Column}\n * @param {ColumnData|RowInfo[]} rowInfo - information about how the rows should be grouped,\n *   see {@link RowInfo}\n * @param {ColumnData|module:columns~ColumnGroup[]} columnGroups - information about how to group\n *   columns. See {@link module:columns~ColumnGroup|ColumnGroup}\n * @param {ColumnData|RowGroup[]} rowGroups - information about how to display row groups,\n *   see {@link RowGroup}\n * @param {module:palettes~PaletteMapping} palettes - mapping of names to palette colors,\n *   see {@link module:palettes~PaletteMapping|PaletteMapping}\n * @param {ColumnData|module:legends~LegendInfo[]} legends - a list of legends to add or configure\n *   for the plot. See {@link module:legends~LegendInfo|LegendInfo}\n * @param {PositionOptions} positionArgs - positioning options, see {@link PositionArgs}\n * @param {HeatmapOptions} options - options for the heatmap\n * @param {boolean} scaleColumn - whether to apply min-max scaling to numerical\n *   columns\n *\n * @returns {SVGElement} - the SVG element containing the heatmap\n *\n */\nfunction funkyheatmap(\n    data,\n    columnInfo,\n    rowInfo = [],\n    columnGroups = [],\n    rowGroups = [],\n    palettes = {},\n    legends = [],\n    positionArgs = {},\n    options = {},\n    scaleColumn = true\n) {\n    [data, columnInfo, columnGroups, rowInfo, rowGroups, legends] = ensureRowData(\n        data, columnInfo, columnGroups, rowInfo, rowGroups, legends\n    );\n    const columns = createColumns(data, columnInfo, scaleColumn, options.colorByRank);\n    columnGroups = buildColumnGroups(columnGroups, columns);\n    legends = prepareLegends(legends, palettes, columns);\n    assignPalettes(columns, palettes);\n    assignPalettes(legends, palettes);\n\n    const svg = d3.select('body')\n        .append('svg')\n            .classed('funkyheatmap', true)\n            .style('visibility', 'hidden')\n            .style('position', 'absolute')\n            .style('left', '-2000px');\n    const heatmap = new FunkyHeatmap(\n        data,\n        columns,\n        columnGroups,\n        rowInfo,\n        rowGroups,\n        palettes,\n        legends,\n        positionArgs,\n        options,\n        svg\n    );\n    heatmap.render();\n    heatmap.listen();\n    heatmap.svg.remove();\n\n    return heatmap.svg.node();\n}\n\nexport default funkyheatmap;\n","module.exports=_;","/** @module */\n\n/**\n * Converts object-based dataframe to array-based dataframe.\n *\n * @param {ColumnData} data - an object with each property representing dataframe column as an array.\n *   Columns are of the same length\n * @returns {RowData} - array of objects with properties corresponding to columns\n */\nexport function colToRowData(data) {\n    const columns = Object.getOwnPropertyNames(data);\n    const size = data[columns[0]].length;\n    const result = [];\n    for (let i = 0; i < size; i++) {\n        let item = {};\n        for (let column of columns) {\n            item[column] = data[column][i];\n        }\n        result.push(item);\n    }\n    return result;\n};\n\n/**\n * Converts array-based dataframe to object-based dataframe.\n *\n * @param {RowData} data - an array of objects with properties\n * @returns {ColumnData} - object with each property representing dataframe column as an array,\n *   values are preserved in the same order as in the input array\n */\nexport function rowToColData(data) {\n    const result = {};\n    const columns = Object.getOwnPropertyNames(data[0]);\n    for (let column of columns) {\n        result[column] = data.map(item => item[column]);\n    }\n    return result;\n};\n\n/**\n * Convenience function to convert potential column-based dataframes to row-based dataframes.\n *\n * @param  {Object[]} objects - potential objects to convert to row-based dataframes. Only converts\n *   objects, skips arrays\n * @returns {Object[]} - array of converted objects\n */\nexport function ensureRowData(...objects) {\n    return objects.map(obj => {\n        if (obj && !Array.isArray(obj)) {\n            obj = colToRowData(obj);\n        }\n        return obj;\n    });\n};\n","/** @module  */\n\nimport * as d3 from 'd3';\nimport _ from 'lodash';\n\nimport { rowToColData } from './input_util';\n\n/**\n * @typedef {Object} ColumnInfo\n * @description Information about a dataframe column and how to display it.\n * @property {string} id - column id in the dataset. _Required_\n * @property {string} name - name of the column to display above the column\n * @property {string} group - name of the group the column belongs to\n * @property {string} geom - type of visualization to display the column data. Default is\n *   `funkyrect` for numerical data, and `text` for categorical data. See {@link module:geoms|geoms}\n *   for available options\n * @property {string} palette - name of the palette to use for coloring the column. Must be defined\n *   in {@link module:palettes~PaletteMapping|PaletteMapping} or be a default palette\n *   (see {@link module:palettes~defaultPalettes|defaultPalettes})\n * @property {string} id_size - id of the column that will determine the size for display\n * @property {string} id_color - id of the column that will determine the color for display\n * @property {boolean} colorByRank - whether to color by rank per column instead of by value\n * @property {boolean} scaleColumn - whether to scale the column data to `[0, 1]`\n * @property {string} label - id of the column that has the values to display as labels over\n *   the geoms\n * @property {string} id_label - synonym for `label`\n * @property {string} id_hover_text - id of the column that has the values to display as hover text\n * @property {number} width - width of the column, only used for `bar` and `image` geoms\n * @property {Object} options - additional options for the column\n * @property {string} options.palette - synonym for `palette`\n * @property {number} options.width - synonym for `width`\n * @property {boolean} options.drawGuide - whether to draw a guide at maximum for the bar geom\n *   column\n * @property {boolean} options.draw_outline - synonym for `options.drawGuide`\n * @property {('left'|'center'|'right')} options.align - alignment of the text for `text` geom\n * @property {number} options.fontSize - font size for the `text` geom\n */\n\n/**\n * @typedef {Object} ColumnGroup\n * @description Information about a group of columns for display. Creating multiple levels of groups\n *   is possible by specifying `level1`, `level2`, etc. with increasing numbers. The columns are not\n *   sorted by <em class=\"pname\">funkyheatmapjs</em>, so the columns should have the groups on the\n *   adjacent positions.\n * @property {string} group - name of the group, must correspond to the `group` field in\n *   {@link module:columns~ColumnInfo|ColumnInfo}\n * @property {string} level1 - name of the first level of the grouping. If not specified, derived\n *   from the `group` field\n * @property {string} level2 - name of the second level of the grouping, if necessary\n * @property {string} level… - further levels of the grouping are possible\n * @property {string} palette - name of the palette to use for coloring the background of the group,\n *   the middle of the palette is used\n */\n\n/**\n * @class\n * @property {string} id - column id in the dataset\n * @property {boolean} numeric - whether the column is numeric, computed from the data.\n *   See {@link module:columns~isNumeric|isNumeric} for details.\n * @property {boolean} categorical - whether the column is categorical, computed from the data\n * @property {string} name - name of the column to display above the column\n * @property {string} group - name of the group the column belongs to\n * @property {string} id_size - id of the column that will determine the size for display\n * @property {string} id_color - id of the column that will determine the color for display\n * @property {boolean} colorByRank - whether to color by rank per column instead of by value, only\n *   for `numeric` columns\n * @property {boolean} scaleColumn - whether to scale the column data to `[0, 1]`\n * @property {string} label - id of the column that has the values to display as labels over the\n *   geoms\n * @property {string} id_hover_text - id of the column that has the values to display as hover text\n * @property {string} geom - type of the geom to display\n * @property {Array} data - array of data for the column\n * @property {number} min - minimum value in the column, for `numeric` columns. `0` if\n *   `scaleColumn === false`\n * @property {number} max - maximum value in the column, for `numeric` columns. `1` if\n *   `scaleColumn === false`\n * @property {number} range - range of the column, for `numeric` columns\n * @property {d3.scaleLinear} scale - scale for the column, for `numeric` columns\n * @property {d3.scaleLinear} colorScale - scale for the color, for `colorByRank` `numeric` columns\n * @property {number[]} rankedData - ranks of the data, for `colorByRank` `numeric` columns\n * @property {Object.<number, number>} normalizedRanks - mapping of rank to normalized rank, for\n *   `colorByRank` `numeric` columns. See\n *   {@link module:columns.Column#maybeCalculateStats|maybeCalculateStats}\n */\nexport class Column {\n    /**\n     * Initialize a column with checks, defaults, and stats calculation.\n     *\n     * @param {module:columns~ColumnInfo} info - column configuration\n     * @param {Array} data - array of data for the column\n     * @param {string[]} columnNames - names of the columns in the dataset, to do cross-checks\n     */\n    constructor(info, data, columnNames) {\n        ({\n            id: this.id,\n            name: this.name,\n            group: this.group,\n            id_size: this.id_size,\n            id_color: this.id_color,\n            colorByRank: this.colorByRank,\n            scaleColumn: this.scaleColumn,\n            label: this.label,\n            id_hover_text: this.id_hover_text,\n            geom: this.geom,\n            palette: this.palette,\n            width: this.width,\n            options: this.options\n        } = info);\n        this.data = data;\n\n        // defaults\n        this.colorByRank = this.colorByRank || false;\n        this.label = this.label || info.id_label;\n\n        const value = data[0];\n        // geoms text and pie are always categorical\n        if (isNumeric(value) && this.geom !== 'text' && this.geom !== 'pie') {\n            this.numeric = true;\n            this.categorical = false;\n        } else {\n            this.numeric = false;\n            this.categorical = true;\n            // disable numerical options for categorical data\n            this.colorByRank = false;\n            this.scaleColumn = false;\n        }\n\n        if (this.name === undefined) {\n            this.name = this.id;\n        }\n\n        if (this.options === undefined) {\n            this.options = {};\n        }\n\n        if (this.options.width !== undefined && this.width === undefined) {\n            this.width = this.options.width;\n        }\n        if (this.options.palette !== undefined && this.palette === undefined) {\n            this.palette = this.options.palette;\n        }\n\n        if (this.geom === undefined) {\n            if (this.numeric) {\n                this.geom = 'funkyrect';\n            } else {\n                this.geom = 'text';\n            }\n        }\n\n        if (this.palette === undefined) {\n            if (this.geom === 'pie') {\n                this.palette = 'categorical';\n            }\n            if (this.geom === 'text') {\n                this.palette = 'none';\n            }\n            if (this.numeric) {\n                this.palette = 'numerical';\n            }\n        }\n\n        if (this.width === undefined) {\n            if (this.geom === 'bar') {\n                this.width = 4;\n            }\n        }\n\n        if (this.geom === 'image' && this.width === undefined) {\n            throw `Please, specify width for column with geom=image`;\n        }\n        if (this.geom === 'bar' && this.options.draw_outline !== undefined) {\n            this.options.drawGuide = this.options.draw_outline;\n        }\n\n        if (this.label !== undefined && !columnNames.includes(this.label)) {\n            throw `Column ${this.id} has label=${this.label}, which is not in the data`;\n        }\n        if (this.id_color !== undefined && !columnNames.includes(this.id_color)) {\n            throw `Column ${this.id} has id_color=${this.id_color}, which is not in the data`;\n        }\n        if (this.id_size !== undefined && !columnNames.includes(this.id_size)) {\n            throw `Column ${this.id} has id_size=${this.id_size}, which is not in the data`;\n        }\n        if (this.id_hover_text !== undefined && !columnNames.includes(this.id_hover_text)) {\n            throw (\n                `Column ${this.id} has id_hover_text=${this.id_hover_text},`\n                + ` which is not in the data`\n            );\n        }\n\n        this.sortState = null;\n        if (this.numeric) {\n            this.maybeCalculateStats();\n        }\n    }\n\n    /**\n     * Calculate stats, scales and maybe ranks for the column. Should be called only for `numeric`\n     * columns. If `colorByRank` is set, data is ranked, and ranks with ties are normalized to\n     * unique ranks.\n     *\n     * Sets `min`, `max`, `range`, `scale`, `colorScale`, `rankedData`, `normalizedRanks`\n     * properties.\n     *\n     * In case there are ties in ranks, d3 will return ranks like `[0, 0, 2]` skipping rank `1`.\n     * So we renormalize the ranks from `[0, 2]` to `[0, 1]`, and map the colors to the number\n     * of unique ranks only. Otherwise we allocate 3 colors for `[0, 0, 2]` data, and the\n     * display colors won't fully map the palette. In this case `normalizedRanks` will be\n     * `{0: 0, 2: 1}`.\n     */\n    maybeCalculateStats() {\n        this.data = this.data.map(d => +d);\n\n        let extent = [0, 1];\n        if (this.scaleColumn) {\n            extent = d3.extent(this.data);\n        }\n        [this.min, this.max] = extent;\n        this.range = this.max - this.min;\n        this.scale = d3.scaleLinear().domain(extent);\n        if (this.colorByRank) {\n            this.rankedData = d3.rank(this.data);\n            const uniqueRanks = _.uniq(this.rankedData);\n            const rankedRanks = d3.rank(uniqueRanks);\n            this.normalizedRanks = _.zipObject(uniqueRanks, rankedRanks);\n            this.colorScale = d3.scaleLinear().domain([0, uniqueRanks.length - 1]);\n        }\n    }\n\n    /**\n     * Get value for the item, which is size for numeric or display for text/pie.\n     *\n     * @param {Object} item - data item with our column\n     * @returns {number|string|number[]} - value for sizing or displaying the item\n     */\n    getValue(item) {\n        if (this.id_size !== undefined) {\n            return item[this.id_size];\n        }\n        if (this.numeric) {\n            return +item[this.id];\n        }\n        return item[this.id];\n    }\n\n    /**\n     * Get value for coloring the item.\n     *\n     * @param {Object} item - data item with our column\n     * @param {number} itemPos - data item position in the dataframe. Needed for getting the rank\n     *   with ties.\n     * @returns {number|string} - value for coloring the item\n     */\n    getColorValue(item, itemPos) {\n        if (this.id_color !== undefined) {\n            return item[this.id_color];\n        }\n        if (this.colorByRank) {\n            const rank = this.rankedData[itemPos];\n            const normalizedRank = this.normalizedRanks[rank];\n            return normalizedRank;\n        }\n        return item[this.id];\n    }\n\n    /**\n     * Get text to display in a tooltip over the geom when mouse hovers it.\n     *\n     * @param {Object} item - data item with our column\n     * @param {number} floatPrecision - number of decimal places to display for float values\n     * @returns {string} - text to display in tooltip when mouse hovers the geom\n     */\n    getHoverText(item, floatPrecision) {\n        if (['text', 'image'].includes(this.geom) && this.id_hover_text === undefined) {\n            return;\n        }\n        let value = item[this.id];\n        if (this.id_hover_text !== undefined) {\n            value = item[this.id_hover_text];\n        }\n        if (this.numeric) {\n            value = +value;\n        }\n        if (_.isNumber(value) && !_.isInteger(value)) {\n            return value.toFixed(floatPrecision);\n        }\n        return `${value}`;\n    }\n\n    sort() {\n        if (this.sortState === \"desc\") {\n            this.sortState = \"asc\";\n            return d3.ascending;\n        }\n        this.sortState = \"desc\";\n        return d3.descending;\n    }\n}\n\n/**\n * Assemble all column information needed for drawing\n *\n * @param {RowData} data - dataset\n * @param {module:columns~ColumnInfo[]} columnInfo - properties of the columns for drawing, which\n *   will by modified in place\n * @param {boolean} scaleColumn - whether to min-max scale data for column, default for all columns\n * @param {boolean} colorByRank - whether to color by rank instead of by value, default for all\n *   columns\n */\nexport function createColumns(data, columnInfo, scaleColumn, colorByRank) {\n    const colData = rowToColData(data);\n    const columnNames = Object.getOwnPropertyNames(colData);\n    if (columnInfo === undefined || columnInfo.length === 0) {\n        console.info(\"No column info specified, assuming all columns are to be displayed.\");\n        columnInfo = Object.getOwnPropertyNames(colData).map(id => {\n            return {id: id}\n        });\n    }\n    if (colorByRank) {\n        columnInfo.forEach(info => {\n            info.colorByRank === undefined && (info.colorByRank = true);\n        });\n    }\n    if (scaleColumn) {\n        columnInfo.forEach(info => {\n            info.scaleColumn === undefined && (info.scaleColumn = true);\n        });\n    }\n    return columnInfo.map(info => {\n        let column = info.id;\n        if (column === undefined) {\n            throw \"Column info must have id field corresponding to the column in the data\";\n        }\n        return new Column(info, colData[column], columnNames);\n    });\n};\n\n/**\n * Check and prepare column group information\n *\n * @param {ColumnGroup[]} columnGroups - information about column groups, empty array if not\n *   specified\n * @param {Column[]} columnInfo - information about columns, to crosscheck\n * @returns {ColumnGroup[]} - column groups with defaults filled in, if necessary\n */\nexport function buildColumnGroups(columnGroups, columnInfo) {\n    if (columnGroups.length === 0 && columnInfo.some(i => i.group)) {\n        console.info(\n            \"No column groups specified, but some columns have group, building automatically\"\n        );\n        columnGroups = columnInfo\n            .filter(i => i.group)\n            .map(i => i.group);\n        columnGroups = [...new Set(columnGroups)];\n        columnGroups = columnGroups.map(group => {\n            return {group: group}\n        });\n    }\n    if (columnGroups.length === 0) {\n        return [];\n    }\n    columnInfo.forEach(i => {\n        if (i.group && !columnGroups.some(g => g.group === i.group)) {\n            throw `Column group ${i.group} is not specified in columnGroups`;\n        }\n    });\n    let allGroups = columnInfo.filter(i => i.group).map(i => i.group);\n    let unused = columnGroups.filter(i => !allGroups.includes(i.group));\n    if (unused.length > 0) {\n        console.warn(`Unused column groups: ${unused.map(i => i.group).join(', ')}`);\n    }\n\n    columnGroups.forEach(i => {\n        if (i.palette === undefined) {\n            i.palette = 'none';\n        }\n    });\n\n    if (columnGroups[0].level1 === undefined) {\n        console.info(\"Column groups did not specify `level1`. Using group id as level1\")\n        columnGroups.forEach(i => {\n            i.level1 = i.group.charAt(0).toUpperCase() + i.group.slice(1);\n        });\n    }\n\n    return columnGroups;\n};\n\n/**\n * Test if a value is a number, including strings that can be coerced to a number.\n *\n * @param {*} str - value to test\n * @returns {boolean} - if the value is a number\n */\nfunction isNumeric(str) {\n    if (typeof str === 'number') return true;\n    if (typeof str !== 'string') return false;\n    // use type coercion to parse the _entirety_ of the string\n    // (`parseFloat` alone does not do this)...\n    return !Number.isNaN(str)\n        && !Number.isNaN(parseFloat(str)); // ...and ensure strings of whitespace fail\n}\n","/** @module */\n\nimport * as d3 from 'd3';\n\n/**\n * @typedef {Object} CustomPalette\n * @property {string[]} colors - list of colors\n * @property {string[]} names - list of names for the colors, in the same order\n * @description A custom palette specification. This is important for categorical data: the names\n *   are used as labels in the legend for `pie` geom, for `text` geom the values are mapped to\n *   colors based on the names.\n */\n\n/**\n * @typedef {string|string[]|module:palettes~CustomPalette} Palette\n * @description A palette specification.\n */\n\n/**\n * @typedef {Object.<string, module:palettes~Palette>} PaletteMapping\n * @description Mapping of names to palette colors. For palette colors the possible options are:\n *   - name of a built-in palette (e.g. `Blues`, `Set1`, etc.). See\n *   {@link module:palettes~defaultPalettes|defaultPalettes}\n *   - `Array.<string>` of custom colors as strings\n *   - {@link module:palettes~CustomPalette|CustomPalette} array of named colors, important for\n *   categorical data\n */\n\n/**\n * Default palettes for numerical and categorical data.\n * @constant {Object}\n * @property {Object} numerical - palettes for numerical data\n * @property {string[]} numerical.Blues - <div class=\"inline-pal-preview\" style=\"background: #011636\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #08306B\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #08519C\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #2171B5\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #4292C6\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #6BAED6\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #9ECAE1\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #C6DBEF\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #DEEBF7\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #F7FBFF\"></div>&nbsp;. Default for\n *   numerical data\n * @property {string[]} numerical.Greens - <div class=\"inline-pal-preview\" style=\"background: #00250f\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #00441B\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #006D2C\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #238B45\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #41AB5D\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #74C476\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #A1D99B\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #C7E9C0\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #E5F5E0\"></div>\n * @property {string[]} numerical.Greys - <div class=\"inline-pal-preview\" style=\"background: #000000\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #252525\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #525252\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #737373\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #969696\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #BDBDBD\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #D9D9D9\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #F0F0F0\"></div>\n * @property {string[]} numerical.Reds - <div class=\"inline-pal-preview\" style=\"background: #CB181D\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #EF3B2C\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FB6A4A\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FC9272\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FCBBA1\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FEE0D2\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFF5F0\"></div>\n * @property {string[]} numerical.YlOrBr - <div class=\"inline-pal-preview\" style=\"background: #EC7014\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FE9929\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FEC44F\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FEE391\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFF7BC\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFFFE5\"></div>\n * @property {Object} categorical - palettes for categorical data\n * @property {string[]} categorical.Set1 - <div class=\"inline-pal-preview\" style=\"background: #E41A1C\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #377EB8\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #4DAF4A\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #984EA3\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FF7F00\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFFF33\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #A65628\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #F781BF\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #999999\"></div>&nbsp;. Default for\n *   categorical data\n * @property {string[]} categorical.Set2 - <div class=\"inline-pal-preview\" style=\"background: #66C2A5\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FC8D62\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #8DA0CB\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #E78AC3\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #A6D854\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFD92F\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #E5C494\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #B3B3B3\"></div>\n * @property {string[]} categorical.Set3 - <div class=\"inline-pal-preview\" style=\"background: #8DD3C7\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFFFB3\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #BEBADA\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FB8072\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #80B1D3\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FDB462\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #B3DE69\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FCCDE5\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #D9D9D9\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #BC80BD\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #CCEBC5\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #FFED6F\"></div>\n * @property {string[]} categorical.Dark2 - <div class=\"inline-pal-preview\" style=\"background: #1B9E77\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #D95F02\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #7570B3\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #E7298A\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #66A61E\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #E6AB02\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #A6761D\"></div>\n *   <div class=\"inline-pal-preview\" style=\"background: #666666\"></div>\n */\nconst defaultPalettes = {\n    numerical: {\n        Blues: [\n            \"#011636\", \"#08306B\", \"#08519C\", \"#2171B5\", \"#4292C6\", \"#6BAED6\", \"#9ECAE1\", \"#C6DBEF\",\n            \"#DEEBF7\", \"#F7FBFF\"\n        ],\n        Greens: [\n            \"#00250f\", \"#00441B\", \"#006D2C\", \"#238B45\", \"#41AB5D\", \"#74C476\", \"#A1D99B\", \"#C7E9C0\",\n            \"#E5F5E0\"\n        ],\n        Greys: [\n            \"#000000\", \"#252525\", \"#525252\", \"#737373\", \"#969696\", \"#BDBDBD\", \"#D9D9D9\", \"#F0F0F0\"\n        ],\n        Reds: [\n            \"#CB181D\", \"#EF3B2C\", \"#FB6A4A\", \"#FC9272\", \"#FCBBA1\", \"#FEE0D2\", \"#FFF5F0\"\n        ],\n        YlOrBr: [\n            \"#EC7014\", \"#FE9929\", \"#FEC44F\", \"#FEE391\", \"#FFF7BC\", \"#FFFFE5\"\n        ]\n    },\n    categorical: {\n        Set1: [\n            \"#E41A1C\",\"#377EB8\",\"#4DAF4A\",\"#984EA3\",\"#FF7F00\",\"#FFFF33\",\"#A65628\",\"#F781BF\",\n            \"#999999\"\n        ],\n        Set2: [\n            \"#66C2A5\",\"#FC8D62\",\"#8DA0CB\",\"#E78AC3\",\"#A6D854\",\"#FFD92F\",\"#E5C494\",\"#B3B3B3\"\n        ],\n        Set3: [\n            \"#8DD3C7\", \"#FFFFB3\", \"#BEBADA\", \"#FB8072\", \"#80B1D3\", \"#FDB462\", \"#B3DE69\", \"#FCCDE5\",\n            \"#D9D9D9\", \"#BC80BD\", \"#CCEBC5\", \"#FFED6F\"\n        ],\n        Dark2: [\n            \"#1B9E77\",\"#D95F02\",\"#7570B3\",\"#E7298A\",\"#66A61E\",\"#E6AB02\",\"#A6761D\",\"#666666\"\n        ]\n    }\n};\n\n/**\n *\n * @param {module:columns.Column[]} columns - array of `Column` objects with information\n * @param {module:palettes~PaletteMapping} palettes - mapping of names to color palettes\n */\nexport function assignPalettes(columns, palettes) {\n    palettes = { numerical: \"Blues\", categorical: \"Set1\", ...palettes };\n    columns.forEach(column => {\n        if (column.palette && column.palette != 'none') {\n            column.paletteName = column.palette;\n            let name = palettes[column.palette];\n            if (name === undefined) { // fallback\n                name = column.palette;\n            }\n            let colors;\n            let colorNames;\n            if (defaultPalettes.numerical[name]) {\n                colors = defaultPalettes.numerical[name];\n            } else if (defaultPalettes.categorical[name]) {\n                colors = defaultPalettes.categorical[name];\n            } else if (Array.isArray(name)) {\n                const item = name[0];\n                if (typeof item === 'string' || item instanceof String) {\n                    colors = name;\n                } else {\n                    throw `Palette definition ${name} is not recognized. Expected are: array of colors, array of color-name pairs.`;\n                }\n            } else if (Array.isArray(name.colors) && Array.isArray(name.names)) {\n                colors = name.colors;\n                colorNames = name.names;\n            } else {\n                const names = [\n                    ...Object.getOwnPropertyNames(defaultPalettes.numerical),\n                    ...Object.getOwnPropertyNames(defaultPalettes.categorical)\n                ];\n                throw `Palette ${name} not defined. Use one of ${names.join(', ')}.`;\n            }\n\n            if (column.numeric) {\n                let scale = column.scale;\n                if (column.colorScale) {\n                    scale = column.colorScale;\n                }\n                const [min, max] = scale.domain();\n                const step = (max - min) / (colors.length - 1);\n                const domain = [...d3.range(min, max, step), max];\n                column.palette = d3.scaleLinear().domain(domain).range(colors);\n            }\n            // TODO: replace with categorical\n            if (column.geom === 'pie' || column.geom === 'text') {\n                let domain = colorNames;\n                if (domain === undefined) {\n                    domain = d3.range(colors.length);\n                }\n                column.palette = d3.scaleOrdinal().domain(domain).range(colors);\n                column.palette.colors = colors;\n                column.palette.colorNames = colorNames;\n            }\n        }\n    });\n};\n","/** @module */\n\nimport * as _ from 'lodash';\n\n/**\n * @typedef {Object} LegendInfo\n * @description Legend configuration\n * @property {string} title - title of the legend, defaults to palette name\n * @property {string} palette - name of the palette to use\n * @property {string} geom - type of geom to use for legend. If absent, will be copied from the\n *   first column info with the same palette\n * @property {string[]} labels - labels for the legend. _Required_ for `text` and `image` geoms.\n *   For `image` geom is a list of captions for the images. For `text` geom is a list of texts\n *   displayed on the left of the legend. For `pie` geom can be inferred from palette, if palette\n *   is specified as a {@link module:palettes~CustomPalette|CustomPalette}. For numeric geoms\n *   defaults to `['0', '', '0.2', '', '0.4', '', '0.6', '', '0.8', '', '1']`\n * @property {('left'|'center'|'right')} label_align - alignment of the labels. Defaults to `center`\n *   for `circle`, `rect` and `funkyrect` geoms\n * @property {number} label_hjust - numerical alias for `label_align`, converts `0, 0.5, 1` to\n *   `left, center, right`, complains about any other values\n * @property {number|number[]} size - size of the legend elements. _Required_ for `image` geom,\n *   will set the width of the image. For `circle` and `funkyrect` geoms defaults to increasing\n *   values from 0 to 1. For `rect` and `bar` geoms defaults to 1. Must be the same length as\n *   `labels`\n * @property {number|number[]} values - values for the legend elements. For numeric geoms represents\n *   color values for the legend elements. Must be the same length as `labels`. _Required_ for\n *   `image` and `text` geoms. For `image` geom is a list of image URLs. For `text` geom is a list\n *   of texts displayed on the right of the legend\n */\n\n/**\n * Validate user-provided legend options and prepare legends for rendering. A legend is necessary\n * for each palette used in the visualization. If user have not provided legend configuration for\n * a palette that is used in {@link module:columns~ColumnInfo|ColumnInfo}, it will be added\n * automatically.\n *\n * @param {module:legends~LegendInfo[]} legends - user provided legend configuration\n * @param {module:palettes~PaletteMapping} palettes - mapping of names to palette colors\n * @param {module:columns.Column[]} columnInfo - user provided information on columns\n */\nexport function prepareLegends(legends, palettes, columnInfo) {\n    if (legends.length === 0) {\n        console.info('No legends provided, will infer automatically');\n        legends = [];\n    }\n\n    const colInfoPalettes = [];\n    columnInfo.forEach(i => {\n        if (i.palette && colInfoPalettes.indexOf(i.palette) === -1) {\n            colInfoPalettes.push(i.palette);\n        }\n    });\n    const legendPalettes = [];\n    legends.forEach(l => {\n        if (l.palette && legendPalettes.indexOf(l.palette) === -1) {\n            legendPalettes.push(l.palette);\n        }\n    });\n\n    const missingPalettes = _.difference(colInfoPalettes, legendPalettes);\n    if (missingPalettes.length > 0) {\n        let msg = 'These palettes are missing in legends, adding legends for them: ';\n        msg += missingPalettes.join(', ');\n        console.info(msg);\n        missingPalettes.forEach(p => {\n            legends.push({\n                title: p,\n                palette: p,\n                enabled: true,\n            });\n        });\n    }\n\n    legends.forEach(legend => {\n        if (legend.enabled === undefined) {\n            legend.enabled = true;\n        }\n        if (legend.title === undefined) {\n            legend.title = legend.palette;\n        }\n        if (legend.geom === undefined) {\n            console.info(`Legend \\`${legend.title}\\` did not specify geom, copying from column info`);\n            const col = columnInfo.find(i => i.palette === legend.palette);\n            legend.geom = col.geom;\n        }\n        if (legend.labels === undefined) {\n            console.info(`Legend \\`${legend.title}\\` did not specify labels, inferring from column info`);\n            if (legend.geom === 'pie') {\n                const pal = palettes[legend.palette];\n                if (pal.names === undefined) {\n                    console.warn(`Cannot infer labels for legend \\`${legend.title}\\`, please provide color names in palette. Disabling this legend`);\n                    legend.enabled = false;\n                }\n                legend.labels = palettes[legend.palette].names;\n            } else if (['circle', 'rect', 'funkyrect', 'bar'].includes(legend.geom)) {\n                // TODO: get from default options\n                legend.labels = ['0', '', '0.2', '', '0.4', '', '0.6', '', '0.8', '', '1'];\n            } else if (legend.geom === 'text' || legend.geom === 'image') {\n                console.warn(`Cannot infer labels for legend \\`${legend.title}\\` of type ${legend.geom}, please provide labels. Disabling this legend`);\n                legend.enabled = false;\n            }\n        }\n        if (legend.label_hjust !== undefined) {\n            if (legend.label_hjust === 0) {\n                legend.label_align = 'left';\n                console.info(`Converting label_hjust=0 to label_align=left for legend \\`${legend.title}\\``);\n            } else if (legend.label_hjust === 1) {\n                legend.label_align = 'right';\n                console.info(`Converting label_hjust=1 to label_align=right for legend \\`${legend.title}\\``);\n            } else if (legend.label_hjust === 0.5) {\n                legend.label_align = 'center';\n                console.info(`Converting label_hjust=0.5 to label_align=center for legend \\`${legend.title}\\``);\n            } else {\n                console.warn(`Unsupported value for label_hjust: ${legend.label_hjust} for legend \\`${legend.title}\\`, ignoring. Only 0, 0.5, 1 are supported`);\n            }\n        }\n        if (legend.label_align === undefined) {\n            if (['circle', 'rect', 'funkyrect'].includes(legend.geom)) {\n                legend.label_align = 'center';\n            }\n        }\n        if (!['left', 'right', 'center'].includes(legend.label_align)) {\n            legend.label_align = 'center';\n            console.warn(`Unsupported value for label_align: ${legend.label_align} for legend \\`${legend.title}\\`, ignoring. Only left, center, right are supported`);\n        }\n        if (legend.size === undefined) {\n            console.info(`Legend \\`${legend.title}\\` did not specify size, inferring from column info`);\n            if (legend.geom === 'circle' || legend.geom === 'funkyrect') {\n                legend.size = [...d3.range(0, legend.labels.length - 1).map(\n                    (i) => i / (legend.labels.length - 1)\n                ), 1];\n            } else if (legend.geom === 'rect' || legend.geom === 'bar') {\n                legend.size = 1;\n            } else if (legend.geom === 'image') {\n                throw `Please specify size (width) for image legend \\`${legend.title}\\``;\n            }\n        }\n        if (legend.values === undefined) {\n            if (['circle', 'rect', 'funkyrect', 'bar'].includes(legend.geom)) {\n                legend.values = [...d3.range(0, legend.labels.length - 1).map(\n                    (i) => i / (legend.labels.length - 1)\n                ), 1];\n            }\n            if (legend.enabled && (legend.geom === 'image' || legend.geom === 'text')) {\n                console.warn(`Cannot infer values for legend \\`${legend.title}\\` of type ${legend.geom}, please provide values. Disabling this legend`);\n                legend.enabled = false;\n            }\n        }\n        if (_.isNumber(legend.size)) {\n            legend.size = Array(legend.labels.length).fill(legend.size);\n        }\n        // TODO: make legend class descend from Column\n        if (['circle', 'rect', 'funkyrect', 'bar'].includes(legend.geom)) {\n            legend.numeric = true;\n            let extent = [0, 1];\n            [legend.min, legend.max] = extent;\n            legend.range = legend.max - legend.min;\n            legend.scale = d3.scaleLinear().domain(extent);\n        }\n    });\n    return legends;\n}\n","/**\n * @module\n * @description Module with available visualization functions (called `geoms`) to display the data.\n * The following table summarizes available geoms for different data types:\n * | Data type | Name | Link | Size mapping | Color mapping |\n * | --- | --- | --- | --- | --- |\n * | `number` | `funkyrect` | {@link module:geoms.funkyrect} | ✅ | ✅ |\n * | `number` | `circle` | {@link module:geoms.circle} | ✅ | ✅ |\n * | `number` | `bar` | {@link module:geoms.bar} | ✅ | ✅ |\n * | `number` | `rect` | {@link module:geoms.rect} | 🚫 | ✅ |\n * | `string` | `text` | {@link module:geoms.text} | 🚫 | ✅ |\n * | `number[]` | `pie` | {@link module:geoms.pie} | 🚫 | ✅ |\n * | `image` | `image` | {@link module:geoms.image} | 🚫 | 🚫 |\n *\n * Each geom is a function with the signature of {@link module:geoms~geom|geom}.\n */\n\nimport * as d3 from 'd3';\n\n/**\n * @name geom\n * @constant\n * @function\n * @abstract\n * @description Abstract virtual function representing a geom.\n *\n * @param {number|number[]|string} value - data value to be visualized, of the above types\n * @param {number|string} colorValue - value to be used for color mapping, if applicable\n * @param {module:columns.Column} column - column object\n * @param {HeatmapOptions} O - heatmap options\n * @param {PositionArgs} P - position arguments\n * @returns {SVGElement} - SVG element representing the geom\n */\n\nexport const GEOMS = {\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Text geom. Renders text string. Configured with `fontSize` and `align` options.\n     *   Default fontSize is inherited from {@link HeatmapOptions}. Default align is `left`.\n     *   Color is mapped from palette by text value, if palette is defined (see\n     *   {@link module:palettes~CustomPalette|CustomPalette}).\n     */\n    text: (value, _, column, O, P) => {\n        let fill = O.theme.textColor;\n        if (column.palette && column.palette !== 'none') {\n            fill = column.palette(value);\n        }\n        let align = 'start', x = 0;\n        if (column.options.align === 'center' || column.options.align === 'middle') {\n            align = 'middle';\n            x = P.rowHeight / 2;\n        }\n        if (column.options.align === 'right' || column.options.align === 'end') {\n            align = 'end';\n            x = P.rowHeight - P.padding;\n        }\n        const el = d3.create('svg:text')\n            .classed('fh-geom', true)\n            .attr('dominant-baseline', 'middle')\n            .attr('y', P.rowHeight / 2)\n            .attr('x', x)\n            .attr('text-anchor', align)\n            .style('fill', fill)\n            .text(value);\n        if (O.fontSize) {\n            el.attr('font-size', O.fontSize);\n        }\n        if (column.options.fontSize) {\n            el.attr('font-size', column.options.fontSize);\n        }\n        return el;\n    },\n\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Bar geom. Renders a bar with width proportional to value. Maximum bar width is\n     *   configured with `width` property ({@link module:columns~ColumnInfo|ColumnInfo}). If value\n     *   is 0, minimal bar width is set from {@link PositionArgs} `minGeomSize`.\n     */\n    bar: (value, colorValue, column, O, P) => {\n        const fill = column.palette(colorValue);\n        value = column.scale(value);\n        let width = value * column.width * P.geomSize;\n        if (width === 0) {\n            width = P.minGeomSize;\n        }\n        return d3.create('svg:rect')\n            .classed('fh-geom', true)\n            .attr('x', P.geomPaddingX)\n            .attr('y', P.geomPadding)\n            .attr('width', width.toFixed(2))\n            .attr('height', P.geomSize)\n            .style('stroke', O.theme.strokeColor)\n            .style('stroke-width', 1)\n            .style('fill', fill);\n    },\n\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Circle geom. Renders a circle with radius proportional to value. If value is 0,\n     *   minimal circle radius is set from {@link PositionArgs} `minGeomSize`.\n     */\n    circle: (value, colorValue, column, O, P) => {\n        const fill = column.palette(colorValue);\n        value = column.scale(value);\n        let radius = value * P.geomSize / 2;\n        if (radius === 0) {\n            radius = P.minGeomSize;\n        }\n        return d3.create('svg:circle')\n            .classed('fh-geom', true)\n            .style('stroke', O.theme.strokeColor)\n            .style('stroke-width', 1)\n            .style('fill', fill)\n            .attr('cx', P.rowHeight / 2)\n            .attr('cy', P.rowHeight / 2)\n            .attr('r', radius.toFixed(2));\n    },\n\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Square geom. Renders a square of standard size, but color is mapped from\n     *   palette.\n     */\n    rect: (value, colorValue, column, O, P) => {\n        const fill = column.palette(colorValue);\n        value = column.scale(value);\n        return d3.create('svg:rect')\n            .classed('fh-geom', true)\n            .style('stroke', O.theme.strokeColor)\n            .style('stroke-width', 1)\n            .style('fill', fill)\n            .attr('x', P.geomPaddingX)\n            .attr('y', P.geomPadding)\n            .attr('width', P.geomSize)\n            .attr('height', P.geomSize);\n    },\n\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Funkyrect geom. Renders a circle that grows into a square with rounded corners.\n     *   Value below {@link PositionArgs} `funkyMidpoint` is rendered as a circle, above as\n     *   a square, with corner radius decreasing as value grows.\n     */\n    funkyrect: (value, colorValue, column, O, P) => {\n        let scaled = column.scale(value);\n        const fill = column.palette(colorValue);\n        if (scaled < P.funkyMidpoint) {\n            // transform value to a 0.0 .. 0.5 range\n            value = column.scale.copy()\n                .range([0, 0.5])\n                .domain([column.min, column.min + column.range * P.funkyMidpoint])(value);\n            let radius = (value * 0.9 + 0.1) * P.geomSize - P.geomPadding; // 0.5 for stroke\n            if (radius <= 0) {\n                radius = P.minGeomSize;\n            }\n            return d3.create('svg:circle')\n                .classed('fh-geom', true)\n                .style('stroke', O.theme.strokeColor)\n                .style('stroke-width', 1)\n                .style('fill', fill)\n                .attr('cx', P.rowHeight / 2)\n                .attr('cy', P.rowHeight / 2)\n                .attr('r', radius.toFixed(2));\n        }\n        // transform value to a 0.5 .. 1.0 range\n        value = column.scale\n            .copy()\n            .range([0.5, 1])\n            .domain([column.min + column.range * P.funkyMidpoint, column.max])(value);\n        const cornerSize = (0.9 - 0.8 * value) * P.geomSize;\n        return d3.create('svg:rect')\n            .classed('fh-geom', true)\n            .style('stroke', O.theme.strokeColor)\n            .style('stroke-width', 1)\n            .style('fill', fill)\n            .attr('x', P.geomPaddingX)\n            .attr('y', P.geomPadding)\n            .attr('width', P.geomSize)\n            .attr('height', P.geomSize)\n            .attr('rx', cornerSize.toFixed(2))\n            .attr('ry', cornerSize.toFixed(2));\n    },\n\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Pie chart geom. Renders a pie chart with slices proportional to values.\n     */\n    pie: (value, _, column, O, P) => {\n        let nonZero = 0;\n        let nonZeroIdx = 0;\n        value.forEach((x, i) => {\n            if (x > 0) {\n                nonZero += 1;\n                nonZeroIdx = i;\n            }\n        });\n        if (nonZero === 1) {\n            const fill = column.palette(nonZeroIdx);\n            return d3.create('svg:circle')\n                .classed('fh-geom', true)\n                .style('stroke', O.theme.strokeColor)\n                .style('stroke-width', 1)\n                .style('fill', fill)\n                .attr('cx', P.rowHeight / 2)\n                .attr('cy', P.rowHeight / 2)\n                .attr('r', P.geomSize / 2);\n        }\n\n        const arcs = d3.pie().sortValues(null)(value);\n        const g = d3.create('svg:g');\n        g.classed('fh-geom', true);\n        g.selectAll('arcs')\n            .data(arcs)\n            .enter()\n            .append('path')\n                .attr('d', d3.arc().innerRadius(0).outerRadius(P.geomSize / 2))\n                .attr('fill', (_, i) => {\n                    return column.palette(i);\n                })\n                .style('stroke', O.theme.strokeColor)\n                .style('stroke-width', 1)\n                .attr('transform', `translate(${P.rowHeight / 2}, ${P.rowHeight / 2})`);\n        return g;\n    },\n\n    /**\n     * @memberof module:geoms\n     * @see {@link module:geoms~geom|geom} for function signature\n     * @description Image geom. Renders an image with standard height and width specified in column\n     *   options (see {@link module:columns~ColumnInfo|ColumnInfo} `width`).\n     */\n    image: function(value, _, column, O, P) {\n        return d3.create('svg:image')\n            .classed('fh-geom', true)\n            .attr('y', P.geomPadding)\n            .attr('href', value)\n            .attr('height', P.geomSize)\n            .attr('width', column.width)\n            .attr('preserveAspectRatio', 'xMidYMid');\n    }\n};\n"],"names":["module","exports","d3","$3gsfO","parcelRequire","$2b6e161c9edcf319$var$DEFAULT_OPTIONS","legendFontSize","legendTicks","labelGroupsAbc","colorByRank","tooltipPrecision","theme","oddRowBackground","evenRowBackground","textColor","strokeColor","headerColorL1","headerColorRest","hoverColor","$2b6e161c9edcf319$var$DEFAULT_POSITION_ARGS","rowHeight","rowSpace","rowBigspace","colWidth","colSpace","colBigspace","colAnnotOffset","colAnnotAngle","padding","minGeomSize","funkyMidpoint","$2b6e161c9edcf319$var$PositionArgs","constructor","args","$32BwG","extend","this","underscoreDeprecatedArgs","deprecatedArgs","key","Object","getOwnPropertyNames","underscore","indexOf","newKey","slice","toUpperCase","push","startsWith","length","msg","join","console","warn","calculate","rowSpacePx","rowBigspacePx","colSpacePx","geomSize","geomPadding","geomPaddingX","$2b6e161c9edcf319$var$FunkyHeatmap","data","columnInfo","columnGroups","rowInfo","rowGroups","palettes","legends","positionArgs","options","svg","rowGroupKey","index","group","merge","calculateOptions","renderGroups","rowGroupOrder","undefined","map","_","forEach","d","i","groupInfo","get","Group","renderStripedRows","O","P","rowGroup","nGroups","colorCounter","body","append","classed","attr","renderData","prevColGroup","offset","bodyHeight","size","column","maxWidth","firstColumn","geom","item","j","width","groupName","$7SRQm","GEOMS","text","node","getBBox","rowGroupWhiteBack","create","value","getValue","isNaN","numeric","label","colorValue","getColorValue","keys","el","labelColor","hsl","palette","l","g","labelX","tooltipValue","getHoverText","datum","tooltip","s2","colorNames","colorName","toFixed","elWidth","select","fontSize","q","drawGuide","widthPx","Math","max","round","bodyWidth","selectAll","raise","renderHeader","headerHeight","nonZeroRotate","groups","header","Array","from","values","nLevels","groupsHeight","labels","abcCounter","level","levelID","levelName","groupStart","columnIdx","nextCol","nextColGroup","groupEnd","groupCol","$dwZfM","Column","id","$lG5F2","assignPalettes","fill","yOffset","rect","diff","letter","String","fromCharCode","charCodeAt","style","on","onColumnClick","bind","name","nativeWidth","rotate","height","getBoundingClientRect","center","renderLegends","footerHeight","legendEl","footer","legendXOffset","legend","enabled","offsetY","title","labelsWidth","txt","myOffset","x","textAnchor","label_align","funkyrect","geomWidth","geomHeight","circle","colors","range","paletteName","enter","col","filter","xPos","img","image","imgWidth","imgHeight","arcs","pie","endAngle","PI","arc","innerRadius","outerRadius","p","centroid","p1","p2","line","legendWidth","footerOffset","hideTooltip","showTooltip","mouse","html","onMouseMove","e","target","parentNode","pointer","document","elBox","comparator","sort","concat","a","b","colData","$kwarp","rowToColData","maybeCalculateStats","selectChildren","remove","render","indicateSort","labelBox","sortIndicator","sortState","y","rootStyle","listen","$2b6e161c9edcf319$export$2e2bcd8739ae039","scaleColumn","ensureRowData","columns","createColumns","buildColumnGroups","$afEFj","prepareLegends","heatmap","$eefee52b0cc720a2$export$7154591d43bbde2b","result","$eefee52b0cc720a2$export$3ce631e14ef22c91","objects","obj","isArray","$eefee52b0cc720a2$export$a599c028b3176012","$9d9dc732a89d186b$export$816b5d811295e6bc","info","columnNames","id_size","id_color","id_hover_text","id_label","str","Number","parseFloat","categorical","draw_outline","includes","extent","min","scale","scaleLinear","domain","rankedData","rank","uniqueRanks","$parcel$interopDefault","uniq","rankedRanks","normalizedRanks","zipObject","colorScale","itemPos","floatPrecision","isNumber","isInteger","ascending","descending","$9d9dc732a89d186b$export$5570d3b32630dd60","$9d9dc732a89d186b$export$e33aac0e3b4702d0","some","Set","allGroups","unused","level1","charAt","$fc81e95648bdd3b9$var$defaultPalettes","numerical","Blues","Greens","Greys","Reds","YlOrBr","Set1","Set2","Set3","Dark2","$fc81e95648bdd3b9$export$e66d39924afea2dc","names","step","scaleOrdinal","$776ad961d55bdd86$export$ba7a034cabddb75f","colInfoPalettes","legendPalettes","missingPalettes","difference","find","label_hjust","$5bd757c5633cec0d$export$848bef37f8dddb4a","align","bar","radius","scaled","copy","cornerSize","nonZero","nonZeroIdx","sortValues"],"version":3,"file":"scIB.8f0250bc.js.map"}